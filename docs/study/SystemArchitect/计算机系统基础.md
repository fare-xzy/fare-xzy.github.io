# 计算机系统基础

## 进程调度算法

在系统架构师考试的计算机系统基础中，进程调度算法是进程管理的核心内容，直接影响系统的性能和资源利用率。以下详细介绍几种常见的进程调度算法：

### 一、先来先服务（First-Come, First-Served，FCFS）

- **基本原理**：按照进程到达就绪队列的先后顺序进行调度，先到达的进程优先获得CPU执行，直到完成或因某种原因（如I/O请求）阻塞才释放CPU。

- **特点**：
  
  - 实现简单，只需维护一个就绪队列，按顺序调度即可。
  - 对长作业有利，但对短作业不利，可能导致短作业长时间等待（“饥饿”现象）。
  - 平均周转时间较长，因为长作业会阻塞后续进程的执行。

- **示例**：若进程A（运行时间10s）先到达，进程B（运行时间2s）后到达，则A先执行10s，完成后B再执行2s，总周转时间为10+12=22s。
  
  ### 二、短作业优先（Shortest Job First，SJF）

- **基本原理**：在就绪队列中，优先选择运行时间最短的进程投入执行（非抢占式）；若有更短的新进程到达，则中断当前进程，优先执行新的短进程（抢占式，也称最短剩余时间优先算法）。

- **特点**：
  
  - 能有效降低平均周转时间和平均等待时间，提高系统吞吐量（单位时间内完成的进程数）。
  - 对长作业不利，可能因不断有短作业到达而长期等待（“饥饿”）。
  - 需预先知道进程的运行时间，实际中难以精确获取（通常基于估计值）。

- **示例**：若进程A（10s）、B（2s）、C（5s）先后到达，SJF会先调度B（2s完成），再调度C（5s完成），最后调度A（10s完成），总周转时间为2+7+17=26s，优于FCFS。
  
  ### 三、优先级调度（Priority Scheduling）

- **基本原理**：为每个进程分配一个优先级（整数表示，数值越大优先级越高或越低，具体依系统而定），调度时优先选择优先级最高的进程执行。

- **分类**：
  
  - 静态优先级：进程创建时确定优先级，且运行期间不变（如根据进程类型、资源需求等设定）。
  - 动态优先级：进程运行期间优先级可动态调整（如等待时间越长，优先级越高，避免“饥饿”）。

- **特点**：
  
  - 灵活性高，可根据系统目标（如实时性、资源利用率）调整优先级策略（如实时进程优先级高于普通进程）。
  - 可能导致低优先级进程长期等待（“饥饿”），需通过“老化”机制（逐渐提高等待进程的优先级）缓解。

- **示例**：优先级P1>P2>P3，若P2正在执行，P1到达则P2被中断，P1优先执行。
  
  ### 四、抢占式与非抢占式（基于调度时机的分类）

- **非抢占式（Non-preemptive）**：
  
  - 进程一旦获得CPU，会一直执行直到完成、阻塞或主动放弃CPU，不会被其他进程中断。
  - 适用于批处理系统，避免频繁切换CPU导致的开销，但实时性较差。
  - 典型算法：FCFS、非抢占式SJF。

- **抢占式（Preemptive）**：
  
  - 若有更高优先级的进程到达或出现更短的进程，当前运行的进程会被中断，CPU被剥夺并分配给新进程。
  
  - 适用于实时系统和分时系统，能保证高优先级进程及时响应，但切换开销较大。
  
  - 典型算法：抢占式SJF、时间片轮转、抢占式优先级调度。
    
    ### 五、时间片轮转（Round Robin，RR）

- **基本原理**：将CPU时间划分为固定长度的“时间片”（如10ms），就绪队列中的进程按顺序轮流获得一个时间片执行；若时间片用完进程未完成，则回到就绪队列末尾等待下一次调度。

- **特点**：
  
  - 公平性好，每个进程都能在固定时间内获得CPU时间，适用于分时系统（如多用户终端）。
  - 时间片长度是关键：过短会导致频繁切换，开销增大；过长则退化为FCFS。
  - 平均响应时间较短，能有效避免“饥饿”现象。

- **示例**：时间片为2s，进程A（10s）、B（2s）、C（5s）依次到达：A执行2s→B执行2s（完成）→C执行2s→A执行2s→C执行1s（完成）→A执行6s（完成），总周转时间更均衡。
  
  ### 六、高响应比优先（Highest Response Ratio Next，HRRN）

- **基本原理**：结合FCFS和SJF的优点，每次调度时计算进程的响应比，优先选择响应比最高的进程执行。响应比公式为： 
  **响应比 =（等待时间 + 运行时间）/ 运行时间 = 1 +（等待时间 / 运行时间）**

- **特点**：
  
  - 等待时间越长，响应比越高（兼顾长作业，避免“饥饿”）；运行时间越短，响应比越高（兼顾短作业）。
  - 综合考虑了进程的等待时间和运行时间，性能优于FCFS和SJF。
  - 需每次调度时计算响应比，增加了系统开销。

- **示例**：进程A（运行10s，已等0s）、B（运行2s，已等0s）、C（运行5s，已等3s），响应比分别为1、1、1.6，故优先调度C。
  
  ### 总结与对比
  
  | 算法                                      | 核心指标       | 优点           | 缺点                | 适用场景         |
  | --------------------------------------- | ---------- | ------------ | ----------------- | ------------ |
  | FCFS                                    | 到达顺序       | 实现简单         | 平均周转时间长，对短作业不利    | 批处理系统（无实时需求） |
  | SJF                                     | 运行时间       | 平均周转时间短      | 长作业可能“饥饿”，需预知运行时间 | 批处理系统（短作业多）  |
  | 优先级调度                                   | 优先级        | 灵活，满足实时需求    | 低优先级进程可能“饥饿”      | 实时系统、多任务系统   |
  | 时间片轮转                                   | 时间片公平分配    | 公平性好，响应快     | 时间片长度难确定，开销大      | 分时系统（多用户交互）  |
  | HRRN                                    | 响应比（等待+运行） | 兼顾长短作业，无“饥饿” | 计算响应比开销大          | 批处理与分时混合系统   |
  | 掌握这些算法的原理、特点及适用场景，是系统架构师考试中进程管理部分的核心要求。 |            |              |                   |              |

在计算机组成原理中，指令流水线通过将指令执行过程分解为多个独立阶段（如取指、译码、执行等），实现多条指令并行处理，从而提升CPU效率。其核心计算涉及**总执行时间、吞吐率、加速比**等指标，需区分理想情况与存在阻塞（气泡）的实际情况。

## 指令流水线
### 一、基础概念与前提
1. **流水线阶段划分**：通常将指令执行分为`n`个阶段（如经典的5阶段：取指IF、译码ID、执行EX、访存MEM、写回WB），每个阶段耗时相等，称为**流水线周期**（记为`Δt`）。  
2. **非流水线对比**：非流水线中，每条指令需依次完成`n`个阶段，总耗时为`n×Δt`；`m`条指令总时间为`m×n×Δt`。  


### 二、理想流水线（无阻塞）的计算
理想情况下，流水线各阶段无冲突（无数据相关、控制相关、结构相关），每条指令进入流水线后依次推进，前一条指令的第2阶段与后一条指令的第1阶段可并行执行。

#### 1. 总执行时间（`T`）
- 第一条指令需完整经过`n`个阶段，耗时`n×Δt`；  
- 从第二条指令开始，每经过1个流水线周期（`Δt`）就有一条指令完成；  
- 因此，`m`条指令的总时间为：  
  $$ T = (n + m - 1) × Δt $$  

  **示例**：5阶段流水线（`n=5`），执行10条指令（`m=10`），总时间为`(5 + 10 - 1)×Δt = 14Δt`。


#### 2. 吞吐率（`TP`）
吞吐率指单位时间内完成的指令数，公式为：  
$$ TP = \frac{\text{完成的指令总数}}{\text{总执行时间}} = \frac{m}{(n + m - 1)×Δt} $$  

- 当指令数`m`极大时（`m >> n`），`TP`趋近于最大值`1/Δt`（每个周期完成1条指令）。  

  **示例**：上述10条指令的吞吐率为`10/(14Δt) ≈ 0.71/Δt`；若`m=1000`，则`TP≈1000/(1004Δt)≈0.996/Δt`，接近最大值。


#### 3. 加速比（`S`）
加速比是“非流水线执行时间”与“流水线执行时间”的比值，衡量效率提升程度：  
$$ S = \frac{\text{非流水线总时间}}{\text{流水线总时间}} = \frac{m×n×Δt}{(n + m - 1)×Δt} = \frac{m×n}{n + m - 1} $$  

- 当`m`极大时，`S≈n`（最大加速比接近流水线阶段数`n`）。  

  **示例**：5阶段流水线执行10条指令，非流水线时间为`10×5×Δt=50Δt`，加速比`S=50/14≈3.57`；若`m=1000`，`S≈5000/1004≈4.98`，接近5。


#### 4. 效率（`E`）
效率指流水线各阶段的利用率，即总工作时间与总可用时间的比值：  
$$ E = \frac{\text{所有阶段的总工作时间}}{\text{所有阶段的总可用时间}} = \frac{m×n×Δt}{n×T} = \frac{m}{n + m - 1} $$  

- 当`m`极大时，`E≈1`（接近100%利用率）。  

  **示例**：10条指令的效率`E=10/14≈0.71`（71%）。


### 三、实际流水线（存在阻塞）的计算
实际中，流水线可能因**数据相关**（指令依赖前序结果）、**控制相关**（分支指令跳转）、**结构相关**（硬件资源冲突）产生阻塞（插入“气泡”，每个气泡耗时`Δt`），导致总时间增加。

#### 1. 总执行时间（`T`）
$$ T = (n + m - 1 + k) × Δt $$  
其中，`k`为阻塞产生的总气泡数（每个气泡对应1个`Δt`）。


#### 2. 关键阻塞场景举例
- **数据相关**：指令`i+1`需使用指令`i`的结果，若结果在`WB`阶段（第5阶段）写回，而`i+1`在`EX`阶段（第3阶段）需要，则需插入2个气泡（等待结果写回），`k`增加2。  
- **控制相关**：分支指令在`ID`阶段（第2阶段）确定跳转，此时已进入`IF`阶段的指令需冲刷，插入1个气泡，`k`增加1。  


#### 3. 计算示例
5阶段流水线（`n=5`），执行10条指令（`m=10`），含2次数据相关（每次2个气泡）和1次分支（1个气泡），则`k=2×2 + 1=5`，总时间：  
$$ T = (5 + 10 - 1 + 5)×Δt = 19Δt $$  

此时吞吐率`TP=10/(19Δt)≈0.53/Δt`，加速比`S=50/19≈2.63`，效率`E=10/(19)≈0.53`。


### 四、总结
指令流水线的计算核心是**总执行时间**，需根据是否存在阻塞分别套用公式：  
- 理想情况：`T=(n + m - 1)×Δt`  
- 实际情况：`T=(n + m - 1 + k)×Δt`（`k`为气泡数）  

在此基础上，可进一步计算吞吐率、加速比和效率，以评估流水线性能。实际应用中，需重点分析阻塞来源（数据/控制/结构相关）以准确计算`k`值。